import { Request, Response, Router } from 'express';
import { ILoggingService, LogFilterParams } from '../../Domain/services/ILoggingService';
import { LogDTO } from '../../Domain/DTOs/LogDTO';
import { LoggingKind } from '../../Domain/enums/LoggingKind';

export class LoggingController {
  private router: Router;
  private loggingService: ILoggingService;
  
  constructor(loggingService: ILoggingService) {
    this.router = Router();
    this.loggingService = loggingService;
    this.initializeRoutes();
  }
  
  public getRouter(): Router { return this.router; }
  
  
  
  private initializeRoutes() {
    // Standard REST endpoint for creating logs (used by other microservices)
    this.router.post("/logs", this.createLog.bind(this));
    this.router.get("/logs", this.getAllLogs.bind(this));
    
    // Original endpoints for internal logging operations
    this.router.post("/logging/store", this.store.bind(this));
    this.router.post("/logging/read", this.read.bind(this)); // params in request body; POST method is needed
    this.router.post("/logging/update", this.update.bind(this));
    this.router.post("/logging/delete", this.delete.bind(this));
    this.router.post("/logging/filter", this.filter.bind(this));
  }
  
  
  
  private async createLog(request: Request, response: Response) {
    const { type, description } = request.body;
    
    if (!type || !description) {
      response.status(400).json({ errMsg: "Missing required fields: type and description" });
      return;
    }
    
    // Map incoming type to LoggingKind enum
    let kind: LoggingKind;
    switch (type.toUpperCase()) {
      case 'INFO':
        kind = LoggingKind.LOGKIND_INFO;
        break;
      case 'WARNING':
        kind = LoggingKind.LOGKIND_WARNING;
        break;
      case 'ERROR':
        kind = LoggingKind.LOGKIND_ERROR;
        break;
      default:
        kind = LoggingKind.LOGKIND_INFO;
    }
    
    const now = new Date();
    const log: LogDTO = {
      id: 0, // Will be auto-generated by database
      kind: kind,
      description: description,
      date: now,
      time: now
    };
    
    const result = await this.loggingService.store(log);
    
    result.match(
      (_) => {
        console.log(`\x1b[36mðŸ“ [LOG]\x1b[0m ${kind} - ${description}`);
        response.status(201).json({ msg: "Log created successfully" });
      },
      (err) => {
        console.error(`\x1b[31mâŒ [LOG ERROR]\x1b[0m Failed to store log: ${err}`);
        response.status(500).json({ errMsg: "Failed to create log", errType: err });
      }
    );
  }
  
  
  
  private async getAllLogs(request: Request, response: Response) {
    const result = await this.loggingService.getAll();
    
    result.match(
      (logs) => { response.status(200).json(logs); },
      (err) => { response.status(500).json({ errMsg: "Failed to retrieve logs", errType: err }); }
    );
  }
  
  
  
  private async store(request: Request, response: Response) {
    if (request.body.log == null) {
      response.status(400).json({ errMsg: "Bad body request", bodyRequest: request.body });
      return;
    }
    
    const log: LogDTO = request.body.log;
    const result = this.loggingService.store(log);
    
    (await result).match(
      (_) => { response.status(200).json({ msg: "Log stored" }) },
      (err) => { response.status(400).json({ errMsg: "Error occured", errType: err }) }
    );
  }
  
  
  
  private async read(request: Request, response: Response) {
    if (request.body.logId == null) {
      response.status(400).json({ errMsg: "Bad body request", bodyRequest: request.body });
      return;
    }
    
    const logId: number = request.body.logId;
    const result = this.loggingService.read(logId);
    
    (await result).match(
      (log) => { response.status(200).json({ returned: log }) },
      (err) => { response.status(400).json({ errMsg: "Error occured", errType: err }) }
    );
  }
  
  
  
  private async update(request: Request, response: Response) {
    if (request.body.log == null) {
      response.status(400).json({ errMsg: "Bad body request", bodyRequest: request.body });
      return;
    }
    
    const log: LogDTO = request.body.log;
    const result = this.loggingService.update(log);
    
    (await result).match(
      (log) => { response.status(200).json({ returned: log }) },
      (err) => { response.status(400).json({ errMsg: "Error occured", errType: err }) }
    );
  }
  
  
  
  private async delete(request: Request, response: Response) {
    if (request.body.logId == null) {
      response.status(400).json({ errMsg: "Bad body request", bodyRequest: request.body });
      return;
    }
    
    const logId: number = request.body.logId;
    const result = this.loggingService.delete(logId);
    
    (await result).match(
      (_) => { response.status(200).json({ msg: `Log #${logId} deleted` }) },
      (err) => { response.status(400).json({ errMsg: "Error occured", errType: err }) }
    );
  }
  
  
  
  private async filter(request: Request, response: Response) {
    if (request.body.params == null) {
      response.status(400).json({ errMsg: "Bad body request", bodyRequest: request.body });
      return;
    }
    
    const params: LogFilterParams = request.body.logId;
    const result = this.loggingService.filter(params);
    
    (await result).match(
      (logs) => { response.status(200).json({ returned: logs }) },
      (err) => { response.status(400).json({ errMsg: "Error occured", errType: err }) }
    );
  }
}
